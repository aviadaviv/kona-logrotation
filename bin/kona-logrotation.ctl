#!/usr/bin/env bash
#
# Auto Generated by Chuck (from the DevOps-API-Tools) at 2023-07-09 06:58:00 +0300
#
# kona-logrotation application rc script
#
# chkconfig:    345 24 76
#
### BEGIN INIT INFO
# Provides:          kona-logrotation
# Required-Start:    $remote_fs
# Required-Stop:     $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start daemon at boot time
# Description:       Enable service provided by daemon.
### END INIT INFO

if [ -f /etc/profile ]; then
  source /etc/profile
fi

PATH=$PATH:/usr/local/bin # for daemon tools

[ -n "${ME}" ]           || ME=`basename $0`
[ -n "${ROOT_FOLDER}" ]  || ROOT_FOLDER="/usr/kona/kona-logrotation/current"
[ -n "${BIN_FOLDER}" ]   || BIN_FOLDER="$ROOT_FOLDER/bin"
[ -n "${ETC_FOLDER}" ]   || ETC_FOLDER="$ROOT_FOLDER/etc"
[ -n "${LOG_FOLDER}" ]   || LOG_FOLDER="$ROOT_FOLDER/log"
[ -n "${VAR_FOLDER}" ]   || VAR_FOLDER="$ROOT_FOLDER/var"
[ -n "${BINARY}" ]       || BINARY="$BIN_FOLDER/kona-logrotation"
[ -n "${PROP_TMPL}" ]    || PROP_TMPL="$ETC_FOLDER/kona-logrotation.cfg.tmpl"
[ -n "${PRODUCT_NAME}" ] || PRODUCT_NAME="kona-logrotation"
[ -n "${RVMRC_FILE}" ]   || RVMRC_FILE="$ROOT_FOLDER/.rvmrc"

# Configuration Server options
[ -n "${CFG_URL}" ]        || CFG_URL='http://config-server/render'
[ -n "${CFG_BACKUP_SUF}" ] || CFG_BACKUP_SUF=`date +%Y%m%d_%H%M%S`

# On integration machines you can set this variable to your local environment
# For example: echo "export CONFIG_SERVER_ENV_NAME=publishers" > /etc/profile.d/config_server.sh
if [ -n "${CONFIG_SERVER_ENV_NAME}" ]; then CFG_ENV=$CONFIG_SERVER_ENV_NAME;else CFG_ENV='production';fi

# Daemon Options
[ -n "${DAEMON_NAME}" ]                  || DAEMON_NAME="kona-logrotation"
[ -n "${PROCESS_OWNER}" ]                || PROCESS_OWNER="kona"
[ -n "${DAEMON_CHILD_RUN_DIR}" ]         || DAEMON_CHILD_RUN_DIR="$BIN_FOLDER"
[ -n "${DAEMON_DELAY_BETWEEN_SPAWN}" ]   || DAEMON_DELAY_BETWEEN_SPAWN="30"
[ -n "${DAEMON_LIMIT_AMOUNT_OF_SPAWN}" ] || DAEMON_LIMIT_AMOUNT_OF_SPAWN="0"
[ -n "${DAEMON_STDOUT}" ]                || DAEMON_STDOUT="${LOG_FOLDER}/daemon.out"
[ -n "${DAEMON_STDERR}" ]                || DAEMON_STDERR="${LOG_FOLDER}/daemon.err"
[ -n "${DAEMON_PIDS_DIR}" ]              || DAEMON_PIDS_DIR="${VAR_FOLDER}"
[ -n "${DAEMON_PID_FILE}" ]              || DAEMON_PID_FILE="${DAEMON_PIDS_DIR}/${DAEMON_NAME}.pid"
[ -n "${DAEMON_CHILD_RUN_CMD}" ]         || DAEMON_CHILD_RUN_CMD="${BINARY}"
[ -n "${DAEMON_CHILD_RUN_ARGS}" ]        || DAEMON_CHILD_RUN_ARGS=""
[ -n "${DAEMON_WAIT_BEFORE_TERMINATE}" ] || DAEMON_WAIT_BEFORE_TERMINATE="2"

if [ `grep $PROCESS_OWNER:x /etc/passwd|wc -l` != "1" ]; then
   echo "ERROR user '$PROCESS_OWNER' is missing"
   exit 1
fi

if [ -f /etc/sysconfig/network ] #include networking configuration functionality. Note doesn't exist on Ubuntu
then
   . /etc/sysconfig/network
   if [ "${NETWORKING}" = "no" ]; then
      echo "ERROR network is off"
      exit 1
   fi
fi

if [ -f $RVMRC_FILE ]; then
  if [ -f /etc/profile.d/rvm.sh ]; then
    source /etc/profile.d/rvm.sh
  else
    source /usr/local/rvm/scripts/rvm
  fi
  source $RVMRC_FILE
fi

start() {
	update_config
    echo "Starting ${PRODUCT_NAME}"
	daemon --name=$DAEMON_NAME \
		--user=$PROCESS_OWNER \
		--chdir=$DAEMON_CHILD_RUN_DIR \
		--inherit \
		--core \
		--respawn  \
		--delay=$DAEMON_DELAY_BETWEEN_SPAWN \
		--limit=$DAEMON_LIMIT_AMOUNT_OF_SPAWN \
		--output=$DAEMON_STDOUT \
		--errlog=$DAEMON_STDERR \
		--pidfiles=$DAEMON_PIDS_DIR \
		--command="${DAEMON_CHILD_RUN_CMD} ${DAEMON_CHILD_RUN_ARGS}" &

    RETVAL=$?
    if [ $RETVAL -eq 0 ]
    then
      RETVAL=1
      daemon_pid=""
      for i in {1..30}
      do
         if [ ! -e "${DAEMON_PID_FILE}" ]
         then
            echo "Waiting for daemon to start ..."
            sleep 2
         else
            daemon_pid=`cat ${DAEMON_PID_FILE}`
            if [ "$daemon_pid" == "" ]; then
               echo "waiting for daemon to start ..."
               sleep 2
            else
               echo "daemon PID: $daemon_pid"
               RETVAL=0
               break
            fi
         fi
      done

      if [ "$daemon_pid" == "" ]; then
         echo "Error: daemon didn't start"
         RETVAL=1
      else
         for i in {1..30}
         do
            product_pid=`ps -f --ppid $daemon_pid | awk '{ print $2 }' | grep -v "[P]ID"`
            if [ "$product_pid" == "" ]; then
               RETVAL=1
               echo "waiting for $PRODUCT_NAME to start ..."
               sleep 2
            else
               RETVAL=0
               echo "$PRODUCT_NAME PID: $product_pid"
               break
            fi
         done
      fi
   fi
   return $RETVAL
}

update_config() {
    for CURR_PROP_TMPL in `find $ETC_FOLDER -name '*.tmpl'`
    do
      CURR_PROP_FILE="${CURR_PROP_TMPL%.*}"

      CFG_CMD="curl --max-time 5 --create-dirs --fail --stderr - -F envname=$CFG_ENV -F cfgfile=@$CURR_PROP_TMPL --output $CURR_PROP_FILE $CFG_URL"

      # Checking if config server templates exists
      if [ -f $CURR_PROP_TMPL ]; then
         # Check if configuration file exists
         if [ -f $CURR_PROP_FILE ]; then
            cp $CURR_PROP_FILE ${CURR_PROP_FILE}_BACKUP_${CFG_BACKUP_SUF}
         fi
         echo "[*] Sending template to configuration server (:env => '$CFG_ENV')"
         $CFG_CMD
         if [ $? -eq 0 ]; then
            echo "[*] Deleting backup files older then 5 days..."
            find ${CURR_PROP_FILE}_BACKUP_* -mtime +5 -exec rm -f {} \; 2> /dev/null
         else
            echo "[*] Failed to update config file"
         fi
      fi
   done
}

list_descendants () {
  echo "$1"
  local children=$(ps -o pid= --ppid "$1")

  for pid in $children;do
    list_descendants "$pid"
  done

  echo "$children"
}

stop() {
   echo "Stopping $PRODUCT_NAME"
   daemon --name=$DAEMON_NAME --user=$PROCESS_OWNER --pidfiles=$DAEMON_PIDS_DIR --running
   RETVAL=$?
   if [ $RETVAL -eq 0 ]; then
      daemon_pid=`cat $DAEMON_PID_FILE`
      product_pid=`ps -f --ppid $daemon_pid | awk '{ print $2 }' | grep -v "[P]ID"`
      daemon --name=$DAEMON_NAME --user=$PROCESS_OWNER --pidfiles=$DAEMON_PIDS_DIR --stop
      for i in $(seq 1 $DAEMON_WAIT_BEFORE_TERMINATE);
      do
         daemon_is_running=`ps -ef | grep -i $daemon_pid | grep -v grep`
         if [ "$daemon_is_running" == "" ]; then
            RETVAL=0
            echo "daemon was stopped"
            break
         else
            RETVAL=1
            echo "waiting for the daemon to stop ..."
            sleep 2
         fi
         done

         if [ $RETVAL -eq 1 ]; then
         echo "the processes daemon( $daemon_pid ) and $PRODUCT_NAME( $product_pid ) refuse to die - they are going to be killed!"
         kill -9 -$daemon_pid 2> /dev/null
         kill -9 -$product_pid 2> /dev/null
         kill -9 $(list_descendants $product_pid) 2>/dev/null # kill all child processes
         kill -9 $daemon_pid $product_pid 2> /dev/null
         RETVAL=0
      fi
   else
      echo "$PRODUCT_NAME is NOT running"
      RETVAL=0
   fi
   rm -f $DAEMON_PID_FILE
   return $RETVAL
}

function restart() {
    echo "Restarting $PRODUCT_NAME"
    stop
    echo 'Stopping - done'
    start
    RETVAL=$?
    echo 'Starting - done'
    return $RETVAL
}

function status() {
  echo "checking $PRODUCT_NAME"
  daemon --name=$DAEMON_NAME --user=$PROCESS_OWNER --pidfiles=$DAEMON_PIDS_DIR --running
  RETVAL=$?
  if [ $RETVAL -eq 0 ]; then
    echo "Daemon is running"
    daemon_pid=`cat $DAEMON_PID_FILE`
    product_pid=`ps -ef | grep -i $BINARY | grep -v grep | grep -v $ME | awk '{ print $2 }'| grep -v "$daemon_pid"`
    echo "daemon PID: $daemon_pid"
    if [ "$product_pid" == "" ]; then
      RETVAL=1
      echo "$PRODUCT_NAME is NOT running"
    else
      echo "$PRODUCT_NAME PID: $product_pid"
    fi
  else
    RETVAL=1
    echo "$PRODUCT_NAME is NOT running"
  fi
  return $RETVAL
}

function killall(){
  echo "killing all daemon processes"
  ps -ef | grep "daemon --name[=]$DAEMON_NAME" | awk '{ print $2 }' | grep -v "[P]ID" | xargs kill -9
  echo "killing all daemon processes - done"
  echo "killing all $DAEMON_NAME processes"
  ps -ef | grep "$ROOT_FOLDER/b[i]n/$PRODUCT_NAME" | awk '{ print $2 }' | grep -v "[P]ID" | xargs kill -9
  echo "killing all $PRODUCT_NAME processes - done"
  rm -f $DAEMON_PID_FILE
  return 0
}

case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    status)
        status
        RETVAL=0
        ;;
    killall)
        killall
        RETVAL=0
        ;;
    *)
        echo "Usage: $ME {start|stop|restart|status|killall}"
        exit 1
esac

exit $RETVAL
